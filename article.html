<!DOCTYPE html>
<html lang="en" class="no-js">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Image Scroll Effects | Demo 1 | Codrops</title>
	<meta name="description" content="A set of creative WebGL-powered image transitions" />
	<meta name="keywords" content="webgl, image transition, distortion, warp, effect, web design" />
	<meta name="author" content="Codrops" />
	<link rel="stylesheet" href="https://use.typekit.net/jsq0suq.css"> 
	<link rel="stylesheet" type="text/css" href="css/base.css" />
	<link rel="stylesheet" type="text/css" href="css/custom.css" />
	<script>
	document.documentElement.className = "js";
	var supportsCssVars = function() { var e, t = document.createElement("style"); return t.innerHTML = "root: { --tmp-var: bold; }", document.head.appendChild(t), e = !!(window.CSS && window.CSS.supports && window.CSS.supports("font-weight", "var(--tmp-var)")), t.parentNode.removeChild(t), e };
	supportsCssVars() || alert("Please view this in a modern browser that supports CSS Variables.");
	</script>
	<script src="//tympanus.net/codrops/adpacks/analytics.js"></script>
</head>

<body>

<!-- ===================================== -->
<!-- For contributors writing the article: -->
<!-- ===================================== -->
<hr><hr><hr><hr>
<h1>Starting with a basic scene</h1>
<p>I love WebGL, and in this article i will explain one of the cool effects you can make if you master shaders. This one is originally from Jesper Landberg official website, he is really cool dude, just go check out his stuff:</p>
<video src="media/video.mp4" looped muted autoplay></video>
<p>So let's get to business! Let's start with a simple HTML file:</p>
<pre>
	&#x3C;div class=&#x22;item&#x22;&#x3E;
	    &#x3C;img src=&#x22;img.jpg&#x22; class=&#x22;js-image&#x22; alt=&#x22;&#x22;&#x3E;
	    &#x3C;h2&#x3E;Some title&#x3C;/h2&#x3E;
	    &#x3C;p&#x3E;Lorem ipsum.&#x3C;/p&#x3E;
	&#x3C;/div&#x3E;
	&#x3C;script src=&#x22;app.js&#x22;&#x3E;&#x3C;/script&#x3E;
</pre>
<p>Couldn't be any easier, we will style it a bit to look prettier:</p>
<figure>
	<img src="media/item.jpg" alt="">
	<figcaption>Style image and some text</figcaption>
</figure>
<p>All the animation will happen in Canvas, so we should also add a bit of javascript, i will be using Parcel for this, as its quite simple to start. And Three.js, because it's the easiest way to use WebGL.</p>
<p>So let's add javascript, you can start with basic Three.js setup, from official repo:</p>
<pre>
	import * as THREE from "three";

	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

	var renderer = new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );


	camera.position.z = 5;

	var animate = function () {
		requestAnimationFrame( animate );

		cube.rotation.x += 0.01;
		cube.rotation.y += 0.01;

		renderer.render( scene, camera );
	};

	animate();
</pre>
<p>it's good to style canvas a bit too:</p>
<pre>
body { margin: 0; }
canvas { 
	display: block; 
	position: fixed;
	z-index: -1; // put it to background
	left:0; top:0; // so it fills whole screen
}
</pre>
<p>Once you have all this in place, you can just run it with `parcel index.html`. Now, you wouldn't see much, its an empty 3D scene so far. Let's leave html for a moment, and concentrate on 3D scene now. </p>

<p>We are going start easy: create a simple PlaneBufferGeometry object with an image on it. Simple as that:</p>
<pre>```
let TEXTURE = new TextureLoader().load('supaAmazingImage.jpg'); 
let mesh = new Mesh(
	new PlaneBufferGeometry(), 
	new MeshBasicMaterial({map: TEXTURE})
)
```</pre>
<p>If you just do that, that's what we are going to see:</p>
<video src="media/video1.mp4" looped muted autoplay></video>
<p>Obviously we are not there yet, we need that color trail following our mouse. And of course, we need shaders for that. And if you are interested in shaders, you probably have seen lots of tutorials on how to displace images with this tech. Like <a href="https://tympanus.net/codrops/2018/04/10/webgl-distortion-hover-effects/">displacing on hover</a> or <a href="https://tympanus.net/codrops/2017/10/10/liquid-distortion-effects/">Liquid distortion effects</a></p>
<p>But we have problem though, we can only use shader on (and inside) that image from the example above. But what we see in the original website, effect is kind of fullscreen, not constrained to any image borders.</p>
<h2>Postprocessing to the rescue</h2>
<p>It turnes out, the output of the Three.js Renderer, is just another image. And we can use that image and use shader displacement on it!</p>
<p>Here is the missing part of code:</p>
<pre>glsl```
	// set up post processing
	let composer = new EffectComposer(renderer);
    let renderPass = new RenderPass(scene, camera);
    // rendering our scene with an image
    composer.addPass(renderPass);

	// our custom shader pass for the whole screen, to displace previous render
    let customPass = new ShaderPass({vertexShader,fragmentShader});
    // making sure we are rendering it.
    customPass.renderToScreen = true;
    composer.addPass(customPass);

	// actually render scene with our shader pass
	composer.render()
	// instead of previous
	// renderer.render(scene, camera);
    ```
</pre>
<p>There is a bunch of stuff happening, but its pretty straightforward in the end. You just apply your shader to the whole screen.</p>
<p>So let's do that final shader with effect, it is actually quite ease:</p>
<pre>
	// get the small circle around mouse, with distances to it.
	float c = circle(uv, mouse, 0.0, 0.2);
	// get texture 3 times, each time with a different offset, depending on mouse speed:
	float r = texture2D(tDiffuse, uv.xy += (mouseVelocity * .5)).x;
	float g = texture2D(tDiffuse, uv.xy += (mouseVelocity * .525)).y;
	float b = texture2D(tDiffuse, uv.xy += (mouseVelocity * .55)).z;
	// combine it all to final output
	color = vec4(r, g, b, 1.);
</pre>
[demo step1.html]

<!-- ===================================== -->
<hr><hr><hr><hr>
<h1>Three images with effect</h1>
<p>Screen has its size, and so do images in 3D, what we need - calculate some relation if those two numbers.</p>
<p>Lets imagine we can make a plane with a width 1, and fit it exactly to screen width. I actually did the same thing in <a href='https://tympanus.net/codrops/2019/11/05/creative-webgl-image-transitions/'>my previous article</a>, well, but that is actually it. Because now  WidthOfPlane=ScreenSize. And in terms of Three.js scene, if want to make an image with an HTML 100px width, we should make a three.js object with width 100*(WidthOfPlane/ScreenSize). That's it! With this kind of math we can also set some margins and positions.</p>
<p>So when the page loads, i will loop through all the images, get their dimensions, and add them to my 3D world:</p>
<pre>```
let images = [...document.querySelectorAll('.js-image')];
images.forEach(image=>{
	// and we have the width,height, and left,top position of the image now!
	let dimensions = image.getBoundingClientRect();
	// hide original image
	image.style.visibility = hidden;
	// add 3D object to your scene, according to its HTML brother dimensions
	createMesh(dimensions);
})
```</pre>
<p>Now its quite straightforward to make this html-3d hybrid:</p>
[step 2]
<p>Another thing that i added here, mouseVelocity. I used it to change radius of the effect. The faster the mouse moves, the bigger is the radius.</p>
<p>Also to make it scrollable, we would just need to move the whole scene, the same distance that screen was scrolled. Using that same formula i mentioned at the start: NumberOfPixels*(WidthOfPlane/ScreenSize). Sometimes its even easier to make WidthOfPlane equal to ScreenSize. That way, you end up with exactly the same numbers in both worlds!</p>
<!-- ===================================== -->
<hr><hr><hr><hr>
<h1>3 images with different effect</h1>

<p>Now, because its shader, you can come up with any kind of effect with this approach. I decided i should play a little with parameters.</p>
<p>So instead of separating image to three color layers, we could just displace it depending on the distance to the mouse:</p>
<pre>
	vec2 newUV = mix(uv, mouse, circle); 
	color = texture2D(tDiffuse,newUV);
</pre>
<p>And for the last effect i used randomization, to get a pixelated effect around mouse cursor.</p>
<p>In this demo you can switch between effects to see some modifications you can make. With "zoom" effect, i just displace it, but in the last one, i also randomize pixels, which looks kinda cool to me, check this out.</p>
[example 3]

<p>I'd be happy to find out your ideas for this animation. What kind of effect you did with this technique?</p>
<hr><hr><hr><hr>
<!-- ===================================== -->
<!-- ===================================== -->
<!-- ===================================== -->
<!-- ===================================== -->
<!-- ===================================== -->
<!-- ===================================== -->
<!-- ===================================== -->




<!-- Can be added in the end of the article -->
<h2>References and Credits</h2>
<ul>
	<li>Article inspired by personal website of  <a href="https://jesperlandberg.dev/">Jesper Landberg</a> </li>
</ul>

</body>

</html>